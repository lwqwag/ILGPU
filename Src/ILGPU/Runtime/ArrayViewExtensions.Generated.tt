// ---------------------------------------------------------------------------------------
//                                        ILGPU
//                        Copyright (c) 2016-2020 Marcel Koester
//                                    www.ilgpu.net
//
// File: ArrayViewExtensions.Generated.tt/ArrayViewExtensions.Generated.cs
//
// This file is part of ILGPU and is distributed under the University of Illinois Open
// Source License. See LICENSE.txt for details.
// ---------------------------------------------------------------------------------------

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file="../Static/TypeInformation.ttinclude"#>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
// Stride name, Needs transpose from/to .Net array
var twoDStrides = new (string, bool)[]
{
    ("DenseX", false),
    ("DenseY", true),
};
var threeDStrides = new (string, bool)[]
{
    ("DenseXY", false),
    ("DenseYZ", true),
};
var dimensionStrides =
    twoDStrides.Select(t => (2, t.Item1, t.Item2)).Concat(
    threeDStrides.Select(t => (3, t.Item1, t.Item2)));
var generalDimensionStrides =
    dimensionStrides.Concat(
        new [] {
            (1, "Dense", false),
            (1, "General", true),
            (2, "General", true),
            (3, "General", true) });
#>
using System;

namespace ILGPU.Runtime
{
    partial class ArrayViewExtensions
    {
        #region Data Allocations

<# foreach (var (dimension, strideName, needsTranspose) in dimensionStrides) { #>
<#      var typeName = $"ArrayView{dimension}D"; #>
<#      var strideTypeName = $"Stride{dimension}D"; #>
        /// <summary>
        /// Allocates a buffer with the specified content on the given accelerator
        /// using the default stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="accelerator">The parent accelerator.</param>
        /// <param name="data">The source CPU data.</param>
        /// <returns>An allocated buffer on the this accelerator.</returns>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        public static 
            MemoryBuffer<<#= typeName #><T, <#= strideTypeName #>.<#= strideName #>>>
            Allocate<#= dimension #>D<#= strideName #><T>(
            this Accelerator accelerator,
            T[<#= string.Join(",", Enumerable.Repeat(string.Empty, dimension)) #>] data)
            where T : unmanaged =>
            Allocate<#= dimension #>D<#= strideName #><T>(
                accelerator,
                accelerator.DefaultStream,
                data);

        /// <summary>
        /// Allocates a buffer with the specified content on the given accelerator.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="accelerator">The parent accelerator.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="data">The source CPU data.</param>
        /// <returns>An allocated buffer on the this accelerator.</returns>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        public static 
            MemoryBuffer<<#= typeName #><T, <#= strideTypeName #>.<#= strideName #>>>
            Allocate<#= dimension #>D<#= strideName #><T>(
            this Accelerator accelerator,
            AcceleratorStream stream,
            T[<#= string.Join(",", Enumerable.Repeat(string.Empty, dimension)) #>] data)
            where T : unmanaged
        {
            if (accelerator is null)
                throw new ArgumentNullException(nameof(accelerator));
            if (data is null)
                throw new ArgumentNullException(nameof(data));
            if (data.Length < 1)
            {
                return new MemoryBuffer<
                    <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>>>(
                    accelerator,
                    <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>>.Empty);
            }

            // Allocate the raw buffer
            var extent = new LongIndex<#= dimension #>D(
                <#= string.Join(
                    ", ",
                    Enumerable.Range(0, dimension).
                    Select(t => $"data.GetLength({t})")) #>);
            var buffer = accelerator.
                Allocate<#= dimension #>D<#= strideName #><T>(extent);

            // Copy the data
            buffer.View.CopyFromCPUSync(stream, data);

            return buffer;
        }

<# } #>

        #endregion

        #region Copy to/from arrays

<# foreach (var (dimension, strideName, needsTranspose) in generalDimensionStrides) { #>
<#      var typeName = $"ArrayView{dimension}D"; #>
<#      var strideTypeName = $"Stride{dimension}D"; #>
<#      var arrayDimExpr = string.Join(",",
            Enumerable.Repeat(string.Empty, dimension)); #>
<#      var arrayType = $"T[{arrayDimExpr}]"; #>
        /// <summary>
        /// Copies the contents of the <#= dimension #>D view into the given
        /// <#= dimension #>D array using the default accelerator stream.
        /// </summary>
        /// <param name="view">The source view.</param>
        /// <param name="data">The target data array.</param>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        public static void CopyToCPUSync<T>(
            this <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>> view,
            <#= arrayType #> data)
            where T : unmanaged =>
            CopyToCPUSync(view, view.GetDefaultStream(), data);

        /// <summary>
        /// Copies the contents of the <#= dimension #>D view into the given
        /// <#= dimension #>D array using the default accelerator stream.
        /// </summary>
        /// <param name="view">The source view.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="data">The target data array.</param>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        public static unsafe void CopyToCPUSync<T>(
            this <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>> view,
            AcceleratorStream stream,
            <#= arrayType #> data)
            where T : unmanaged
        {
            if (data is null)
                throw new ArgumentNullException(nameof(data));
            if (data.Length < 1)
                return;
            if (data.Length > view.Length)
                throw new ArgumentOutOfRangeException(nameof(data));

<#      if (!needsTranspose) { #>
            fixed (T* ptr = data)
            {
                view.BaseView.CopyToCPUSync(
                    stream,
                    new Span<T>(ptr, data.Length));
            }
<#      } else { #>
            var tempBuffer = new T[data.Length];
            fixed (T* ptr = tempBuffer)
            {
                view.BaseView.CopyToCPUSync(
                    stream,
                    new Span<T>(ptr, tempBuffer.Length));
            }
            fixed (T* ptr = data)
            {
                var span = new Span<T>(ptr, data.Length);

                // Transpose the input elements and store them in the result buffer
                var extent = (Index<#= dimension #>D)view.Extent;
                var stride = view.Stride;
<#      for (int i = 0; i < dimension; ++i) { #>
<#          var fieldName = IndexDimensions[i].FieldName; #>
                for (
                    int <#= fieldName #> = 0;
                    <#= fieldName #> < extent.<#= IndexDimensions[i].PropertyName #>;
                    ++<#= fieldName #>)
                {
<#      } #>
                    var multiDimIndex = new Index<#= dimension #>D(<#= string.Join(
                        ", ",
                        IndexDimensions.Take(dimension).Select(t => t.FieldName)) #>);
                    int elementIndex = stride.ComputeElementIndex(multiDimIndex);
                    int sourceElementIndex = multiDimIndex.ComputeLinearIndex(extent);
                    span[elementIndex] = tempBuffer[sourceElementIndex];
<#      for (int i = 0; i < dimension; ++i) { #>
                }
<#      } #>
            }
<#      } #>
        }

        /// <summary>
        /// Copies the contents of the <#= dimension #>D array into the given
        /// <#= dimension #>D view using the default accelerator stream.
        /// </summary>
        /// <param name="view">The source view.</param>
        /// <param name="data">The target data array.</param>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        public static void CopyFromCPUSync<T>(
            this <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>> view,
            <#= arrayType #> data)
            where T : unmanaged =>
            CopyFromCPUSync(view, view.GetDefaultStream(), data);

        /// <summary>
        /// Copies the contents of the <#= dimension #>D array into the given
        /// <#= dimension #>D view using the default accelerator stream.
        /// </summary>
        /// <param name="view">The source view.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="data">The target data array.</param>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        public static unsafe void CopyFromCPUSync<T>(
            this <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>> view,
            AcceleratorStream stream,
            <#= arrayType #> data)
            where T : unmanaged
        {
            if (data is null)
                throw new ArgumentNullException(nameof(data));
            if (view.HasNoData())
                return;
            if (view.Length > data.Length)
                throw new ArgumentOutOfRangeException(nameof(data));

<#      if (needsTranspose) { #>
            var tempBuffer = new T[data.Length];
            fixed (T* ptr = data)
            {
                var span = new ReadOnlySpan<T>(ptr, data.Length);

                // Transpose the input elements and store them in the result buffer
                var extent = (Index<#= dimension #>D)view.Extent;
                var stride = view.Stride;
<#      for (int i = 0; i < dimension; ++i) { #>
<#          var fieldName = IndexDimensions[i].FieldName; #>
                for (
                    int <#= fieldName #> = 0;
                    <#= fieldName #> < extent.<#= IndexDimensions[i].PropertyName #>;
                    ++<#= fieldName #>)
                {
<#      } #>
                    var multiDimIndex = new Index<#= dimension #>D(<#= string.Join(
                        ", ",
                        IndexDimensions.Take(dimension).Select(t => t.FieldName)) #>);
                    int elementIndex = stride.ComputeElementIndex(multiDimIndex);
                    int sourceElementIndex = multiDimIndex.ComputeLinearIndex(extent);
                    tempBuffer[elementIndex] = span[sourceElementIndex];
<#      for (int i = 0; i < dimension; ++i) { #>
                }
<#      } #>
            }
<#      } else { #>
            var tempBuffer = data;
<#      } #>
            fixed (T* ptr = tempBuffer)
            {
                view.BaseView.CopyFromCPUSync(
                    stream,
                    new ReadOnlySpan<T>(ptr, tempBuffer.Length));
            }
        }

<# } #>

        #endregion

        #region GetAsArray

<# foreach (var (dimension, strideName, _) in generalDimensionStrides) { #>
<#      var typeName = $"ArrayView{dimension}D"; #>
<#      var strideTypeName = $"Stride{dimension}D"; #>
        /// <summary>
        /// Copies the contents of the <#= dimension #>D view into a new
        /// <#= dimension #>D array
        /// while transposing the input buffer on the CPU.
        /// </summary>
        /// <param name="view">The source view.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <returns>A new array holding the requested contents.</returns>
        public static 
            T[<#= string.Join(",", Enumerable.Repeat(string.Empty, dimension)) #>]
            GetAs<#= dimension #>Array<T>(
            this <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>> view,
            AcceleratorStream stream)
            where T : unmanaged
        {
            if (view.HasNoData())
                return new T[<#= string.Join(
                    ", ",
                    Enumerable.Repeat("0", dimension)) #>];

            // Allocate the return array
            var result = new T[
                <#= string.Join(
                    ", ",
                    Enumerable.Range(0, dimension).
                    Select(t => $"view.Extent.{IndexDimensions[t].PropertyName}")) #>];

            // Copy the data
            view.CopyToCPUSync(stream, result);

            return result;
        }

<# } #>

        #endregion
    }
}